main :THEORY
 BEGIN
  IMPORTING pilldispenser_th

  %-- AVAILABLE ACTIONS
  available_actions_exectype : TYPE = list[ actions_type ]
  available_actions_T2X(a: available_actions_type): available_actions_exectype =
    IF a(key1) THEN (: key1 :) ELSE null ENDIF o
    IF a(key2) THEN (: key2 :) ELSE null ENDIF o
    IF a(key3) THEN (: key3 :) ELSE null ENDIF o
    IF a(confirm) THEN (: confirm :) ELSE null ENDIF o
    IF a(create) THEN (: create :) ELSE null ENDIF o
    IF a(quit) THEN (: quit :) ELSE null ENDIF o
    IF a(bottom) THEN (: bottom :) ELSE null ENDIF o
    IF a(scan_action) THEN (: scan_action :) ELSE null ENDIF o
    IF a(tick) THEN (: tick :) ELSE null ENDIF o
    IF a(medicines) THEN (: medicines :) ELSE null ENDIF o
    IF a(drug_id_line) THEN (: drug_id_line :) ELSE null ENDIF o
    IF a(database) THEN (: database :) ELSE null ENDIF o
    IF a(reload) THEN (: reload :) ELSE null ENDIF o
    IF a(unload) THEN (: unload :) ELSE null ENDIF o
    IF a(prescriptions) THEN (: prescriptions :) ELSE null ENDIF
  CONVERSION available_actions_T2X
  test_actions: available_actions_exectype = LAMBDA(x: actions_type): (x = key1) OR (x = key2) OR (x = key3)
  action_available?(x: actions_type, a: available_actions_exectype): RECURSIVE bool =
    IF null?(a) THEN FALSE
    ELSE IF car(a) = x THEN TRUE ELSE action_available?(x, cdr(a)) ENDIF ENDIF
  MEASURE length(a)
  available_actions_X2T(f: available_actions_exectype): available_actions_type =
    LAMBDA(x: actions_type):
       COND
         x = key1 -> action_available?(x, f),
         x = key2 -> action_available?(x, f),
         x = key3 -> action_available?(x, f),
         x = confirm -> action_available?(x, f),
         x = create -> action_available?(x, f),
         x = quit -> action_available?(x, f),
         x = bottom -> action_available?(x, f),
         x = scan_action -> action_available?(x, f),
         x = tick -> action_available?(x, f),
         x = medicines -> action_available?(x, f),
         x = drug_id_line -> action_available?(x, f),
         x = database -> action_available?(x, f),
         x = reload -> action_available?(x, f),
         x = unload -> action_available?(x, f),
         x = prescriptions -> action_available?(x, f)
       ENDCOND
%  CONVERSION available_actions_X2T

  %-- AVAILABLE FIELDS
  available_fields_exectype: TYPE = list[[#
    field_name: fields_type,
    field_status: field_status_type
  #]]
  N_FIELDS: posnat = 19
  f_index: TYPE = below(N_FIELDS)
  f_index2fields_type(x: f_index): fields_type =
    COND
      x = 0 -> password,
      x = 1 -> dob,
      x = 2 -> medicine,
      x = 3 -> dosage,
      x = 4 -> id_card,
      x = 5 -> mob,
      x = 6 -> carer,
      x = 7 -> prescription,
      x = 8 -> name,
      x = 9 -> dose,
      x = 10 -> validity,
      x = 11 -> quantity,
      x = 12 -> column,
      x = 13 -> monthly,
      x = 14 -> weekly,
      x = 15 -> daily,
      x = 16 -> bidaily,
      x = 17 -> time1,
      x = 18 -> time2
    ENDCOND
  CONVERSION f_index2fields_type
  fields_type2f_index(x: fields_type): f_index =
    COND
      x = password -> 0,
      x = dob -> 1,
      x = medicine -> 2,
      x = dosage -> 3,
      x = id_card -> 4,
      x = mob -> 5,
      x = carer -> 6,
      x = prescription -> 7,
      x = name -> 8,
      x = dose -> 9,
      x = validity -> 10,
      x = quantity -> 11,
      x = column -> 12,
      x = monthly -> 13,
      x = weekly -> 14,
      x = daily -> 15,
      x = bidaily -> 16,
      x = time1 -> 17,
      x = time2 -> 18
    ENDCOND
  CONVERSION fields_type2f_index

  available_fields_type2exectype_aux(f: available_fields_type, n: f_index): RECURSIVE available_fields_exectype =
    IF n = N_FIELDS THEN null
    ELSE (: (# field_name := f_index2fields_type(n), field_status := f(n) #) :) o available_fields_type2exectype_aux(f, n + 1) ENDIF
  MEASURE (N_FIELDS - n)
  available_fields_T2X(f: available_fields_type): available_fields_exectype = available_fields_type2exectype_aux(f, 0)
  CONVERSION available_fields_T2X
  
  available_fields_X2T(f: available_fields_exectype): available_fields_type =
    LAMBDA(x: fields_type): LET pos: f_index = fields_type2f_index(x) IN nth(f, pos)`field_status
%  CONVERSION available_fields_X2T

  %-- sanity check
  test_fields: available_fields_exectype =
    LAMBDA (f: fields_type):
    	    IF f = dob THEN (# visible := true, selected := false, entered := false #)
	    ELSE (# visible := false, selected := false, entered := false #) ENDIF
  test_reverse_fields: bool =
    LET rec = LAMBDA (f: fields_type):
    	    IF f = dob THEN (# visible := true, selected := false, entered := false #)
	    ELSE (# visible := false, selected := false, entered := false #) ENDIF
    IN FORALL(x: fields_type): available_fields_X2T(available_fields_T2X(rec))(x) = rec(x)
  
  
  %-- MEDICINE DATABASE
  med_db_exectype: TYPE = list[[#
    pos: m_index,
    val: available_fields_exectype
  #]]
  
  med_db_type2exectype_aux(m: med_db_type, n: m_index): RECURSIVE med_db_exectype =
    LET v: available_fields_exectype = m(n) IN
    IF n = 0 THEN (: (# pos:= n, val:= v #) :)
    ELSE (: (# pos:= n, val:= v #) :) o med_db_type2exectype_aux(m, n-1) ENDIF
  MEASURE n
  med_db_T2X(m: med_db_type): med_db_exectype = med_db_type2exectype_aux(m, mlimit)
  CONVERSION med_db_T2X

  med_db_X2T(m: med_db_exectype): med_db_type =
    LAMBDA(x: m_index): available_fields_X2T(nth(m, x)`val)
%  CONVERSION med_db_X2T

  %-- sanity check
  test_med_db: med_db_exectype =
    LET rec = (LAMBDA (f: fields_type): (# visible := false, selected := false, entered := false #))
     IN LAMBDA(m: m_index): rec
  test_reverse_med_db: bool =
    LET rec = LAMBDA (f: fields_type): (# visible := false, selected := false, entered := false #),
        db = LAMBDA(m: m_index): rec
    IN FORALL(m: m_index, f: fields_type): med_db_X2T(med_db_T2X(db))(m)(f) = db(m)(f)


  %-- PATIENT DATABASE
  patient_db_exectype: TYPE = list[[#
    pos: p_index,
    val: available_fields_exectype
  #]]
  
  patient_db_type2exectype_aux(p: patient_db_type, n: p_index): RECURSIVE patient_db_exectype =
    LET v: available_fields_exectype = p(n) IN
    IF n = 0 THEN (: (# pos:= n, val:= v #) :)
    ELSE (: (# pos:= n, val:= v #) :) o patient_db_type2exectype_aux(p, n-1) ENDIF
  MEASURE n
  patient_db_T2X(p: patient_db_type): patient_db_exectype = patient_db_type2exectype_aux(p, plimit)
  CONVERSION patient_db_T2X

  patient_db_X2T(p: patient_db_exectype): patient_db_type = LAMBDA(x: p_index): available_fields_X2T(nth(p, x)`val)
%  CONVERSION patient_db_X2T

  %-- sanity check
  test_patient_db: patient_db_exectype =
    LET rec = (LAMBDA (f: fields_type): (# visible := false, selected := false, entered := false #))
     IN LAMBDA(p: p_index): rec
  test_reverse_patient_db: bool =
    LET rec = LAMBDA (f: fields_type): (# visible := false, selected := false, entered := false #),
        db = LAMBDA(p: p_index): rec
    IN FORALL(p: p_index, f: fields_type): patient_db_X2T(patient_db_T2X(db))(p)(f) = db(p)(f)

  %-- PATIENT ID LINE
  patient_id_line_exectype: TYPE = list[[#
    pos: p_index,
    val: bool
  #]]
  patient_id_line_type2exectype_aux(p: patient_id_line_type, n: p_index): RECURSIVE patient_id_line_exectype =
    IF n = 0 THEN (: (# pos:= n, val:= p(n) #) :)
    ELSE (: (# pos:= n, val:= p(n) #) :) o patient_id_line_type2exectype_aux(p, n-1) ENDIF
  MEASURE n
  patient_id_line_T2X(p: patient_id_line_type): patient_id_line_exectype = patient_id_line_type2exectype_aux(p, plimit)
  CONVERSION patient_id_line_T2X

  patient_id_line_X2T(p: patient_id_line_exectype): patient_id_line_type = LAMBDA(x: p_index): nth(p, x)`val
%  CONVERSION patient_id_line_X2T


  test_patient_id_line: patient_id_line_exectype = LAMBDA (x: p_index): false
  test_reverse_patient_id_line: bool =
    LET line = LAMBDA (x: p_index): false
     IN FORALL(p: p_index, f: fields_type): patient_id_line_X2T(patient_id_line_T2X(line))(p) = line(p)


  


  execState: TYPE = [#
   mode: mode_type,
   action: available_actions_exectype,
   field: available_fields_exectype,
   new_patient_record: available_fields_exectype,
   patient_id_line: patient_id_line_exectype,
%   med_id_line: med_id_line_type,
%   script_line: script_line_type,
%   scripts_db: script_db_type,
   patients_db: patient_db_exectype,
   meds_db: med_db_exectype,
   p_max: p_index,
   p_lower: p_index,
   p_upper: p_index,
   p_current: p_index,
   m_max: m_index,
   m_lower: m_index,
   m_upper: m_index,
   m_current: m_index,
   s_lower: s_index,
   s_upper: s_index,
   s_current: s_index,
   scan_counter: upto(max_scan)
  #]
  state2execState(st: state): execState = (#
   mode:= mode(st),
   action:= action(st),
   field:= field(st),
   new_patient_record:= new_patient_record(st),
   patient_id_line:= patient_id_line(st),
%   med_id_line: med_id_line_type,
%   script_line: script_line_type,
%   scripts_db: script_db_type,
   patients_db:= patients_db(st),
   meds_db:= meds_db(st),
   p_max:= p_max(st),
   p_lower:= p_lower(st),
   p_upper:= p_upper(st),
   p_current:= p_current(st),
   m_max:= m_max(st),
   m_lower:= m_lower(st),
   m_upper:= m_upper(st),
   m_current:= m_current(st),
   s_lower:= s_lower(st),
   s_upper:= s_upper(st),
   s_current:= s_current(st),
   scan_counter:= scan_counter(st)
  #)
  CONVERSION state2execState
  exec(st: state): execState = state2execState(st)

  execState2state(st: execState): state = (#
   mode:= mode(st),
   action:= action(st),
   field:= available_fields_X2T(field(st)),
   new_patient_record:= available_fields_X2T(new_patient_record(st)),
   patient_id_line:= patient_id_line_X2T(patient_id_line(st)),

   med_id_line :=
       LAMBDA (x: m_index): false,
   script_line :=
       LAMBDA (x: s_index): false, 
   scripts_db :=
       LET rec = (LAMBDA (f: fields_type): (# visible := false, selected := false, entered := false #)),
           dos = (LAMBDA(s: s_index): rec) IN
       LAMBDA (p: p_index): (# s_max := 0, s_lines := dos, s_doses := dos #),
   
   patients_db:= patient_db_X2T(patients_db(st)),
   meds_db:= med_db_X2T(meds_db(st)),
   p_max:= p_max(st),
   p_lower:= p_lower(st),
   p_upper:= p_upper(st),
   p_current:= p_current(st),
   m_max:= m_max(st),
   m_lower:= m_lower(st),
   m_upper:= m_upper(st),
   m_current:= m_current(st),
   s_lower:= s_lower(st),
   s_upper:= s_upper(st),
   s_current:= s_current(st),
   scan_counter:= scan_counter(st)
  #)
  CONVERSION execState2state

  init(x: real): execState =
    LET precompile = act_key1(init_pillbox(0)),
        precompile = act_key2(init_pillbox(0)),
        precompile = act_key3(init_pillbox(0))
     IN init_pillbox(0)
  st0: state = init_pillbox(0);

  auto_password(st: state): state =
      st
        WITH [field
                := LAMBDA (x: fields_type):
                     COND x = password ->
                            (# visible := TRUE,
                               selected := FALSE,
                               entered := TRUE #),
                          ELSE -> st`field(x)
                     ENDCOND]

  %-- APIS
  click_key_act1(st: state): execState =
    COND
      per_act_key1(st) -> act_key1(st),
      ELSE -> st
    ENDCOND
  click_key_act2(st: state): execState =
    COND
      per_act_key2(st) -> auto_password(act_key2(st)),
      ELSE -> st
    ENDCOND
  click_key_act3(st: state): execState =
    COND
      per_act_key3(st) -> auto_password(act_key3(st)),
      ELSE -> st
    ENDCOND
  click_act_confirm(st: state): execState =
    COND
      per_act_confirm(st) -> act_confirm(st),
      ELSE -> st
    ENDCOND


  %-- NOTES
  % A FIELD CAN BE SELECTED ONLY IF THE FIELD IS VISIBLE
  b1: available_fields_exectype = exec(select(dob, st0))`field; %-- field dob is not selected
  
  b2: available_fields_exectype = exec(select(dob, st0 WITH [
      	field := LAMBDA (f: fields_type):
	      	     IF f = dob THEN (# visible := true, selected := false, entered := false #)
                     ELSE (# visible := false, selected := false, entered := false #) ENDIF
	]))`field; %-- field dob is correctly selected in this case because the field is visible

  b3: available_fields_exectype = exec(new_patient_details_screen(st0))`field
  st1: state = new_patient_details_screen(st0) %-- dob is visible
  b4: available_fields_exectype = exec(enter(dob, select(dob, st1)))`field %-- dob selected correctly

 END main
